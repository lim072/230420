/*
어떤코드를 바로 실행하지 않고 일정 시간 딜레이한 후에 실행해야하는 경우가 있습니다
이럴때는 setTimeout이라는 내장함수
첫번째 인수는 콜백함수, 두번째 인수는 시간(밀리초단위)
*/

//setTimeout(()=>console.log("2초 후에 실행됩니다"), 2000 );

//setTimeout(콜백함수,시간);


function test(delay,callback){
    setTimeout(()=>{
        callback();
    },delay)
}

//test라는 함수는 2가지의 인수를 받아서 setTimeout을 호출하는 함수입니다


// test(()=>{console.log("콜백"),1000});


/*
동기식 방식과 비동기식 방식

동기식 방식은 직렬형으로 A작업이 끝나야지만 후속으로 B작업을 처리할 수 있는 방법입니다
이 방법은 대략적으로 처리되는 일의 시작과 끝나는 시간을 짐작할 수 있습니다

반면 비동기식 방식은 병렬형으로 작업에 참여하는 주체만큼 동시에 작업이 시작될 수 있습니다
이 방법은 어떤 주체가 처리를 마칠지를 가늠할 수 없기 때문에 일의 시작과 끝을
짐작할 수 없습니다

따라서 반드시 A작업이 마치고 B작업이 실행되어야 하는 경우 무조건 동기식의 방법으로 처리를
해야 합니다
*/

//순서1. 스타트 콘솔문이 실행됩니다(js)
// console.log("start");

// //순서2. test함수를 호출(js) -> 셋타임아웃구문이 webapi에 전달(js)
// test(()=>{
//     console.log("콜백1"); //순서6. 셋타임아웃을 처리하고 그 안쪽에서 콜백으로
//                           // 정의한 콘솔문이 js에 전달됩니다(wb api)
// }, 0);

// //순서3. test함수를 호출(js) -> 셋타임아웃구문이 webapi에 전달(js)
// test(()=>{
//     console.log("콜백2"); //순서7. 셋타임아웃을 처리하고 그 안쪽에서 콜백으로
//                           // 정의한 콘솔문이 js에 전달됩니다(wb api)
// }, 1000);

// //순서4. test함수를 호출(js) -> 셋타임아웃구문이 webapi에 전달(js)
// test(()=>{
//     console.log("콜백3");  //순서8. 셋타임아웃을 처리하고 그 안쪽에서 콜백으로
//                             // 정의한 콘솔문이 js에 전달됩니다(wb api)
// }, 2000);

// //순서5. 엔드 콘솔문이 실행 됩니다 (js)
// console.log("end")


/*
위의 코드가 만약 자바스크립트 엔진에서만 작동하는 작업이라면 당연히 동기적으로 실행되어
예상하는대로 스타트 테스트함수들 엔드 가 작업결과가 되겠지만
셋타임아웃을 호출하는 함수인 test함수를 작업하기 때문에 web API와 분담하는 작업이 됩니다
따라서 비동기적으로 작동할 수 밖에 없는 구조입니다
*/

console.log("start");

test(2000, ()=>{
    console.log("콜백1");
    test(2000, ()=>{
        console.log("콜백2");
        test(2000,()=>{
            console.log("콜백3");
            console.log("end")
        })
    })
})

/*
콜백함수 : 함수가 종료되는 시점에 다시 함수를 호출하여서 동기적으로 실행할 수 있게 하는 방법
단 점 : 코드가 난잡하고, 보기 불편해서 유지보수성도 없어 쓰기 불편합니다

하지만 콜백을 그러함에도 불구하고 사용합니다 단 복잡한 코드에서는 다른 방법을 차용하고,
단순 그 다음으로 연결될 동기적인 상황에서는 콜백을 애용합니다

이벤트 함수는 다 콜백 함수

따라서
동기적 작동방식 1단계 : 콜백함수
2단계 : promise
3단계 : async await
*/



